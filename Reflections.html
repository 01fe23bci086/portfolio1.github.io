<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reflection on Data Structures and Algorithms</title>
    <style>
        * { 
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #f4f4f4;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        header h1 {
            color: #333;
        }

        section h2 {
            margin-top: 20px;
            color: #4CAF50;
        }

        section h3 {
            margin-top: 10px;
            color: #2196F3;
        }

        section p {
            color: #555;
            margin: 10px 0;
            font-size: 16px;
        }

        pre {
            background-color: #f4f4f4;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 10px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Reflection on Learning Data Structures and Algorithms</h1>
        </header>
        
        <section class="intro">
            <p>Throughout this course, I delved deep into fundamental data structures and algorithms, which are the backbone of efficient computing. Key topics I explored include <strong>Time Complexity Analysis</strong>, <strong>Binary Search Trees (BST)</strong>, <strong>DFS and BFS</strong>, <strong>Heap Sorting</strong>, <strong>Pattern Searching</strong>, and <strong>Graph Algorithms</strong>. Here's a reflection on what I learned, the challenges I faced, and how I approached solving complex problems.</p>
        </section>
        
        <section class="concepts">
            <h2>Key Concepts Learned</h2>
            <h3>1. Time Complexity Analysis</h3>
            <p>Time complexity analysis is essential for determining the efficiency of algorithms. By mastering <strong>Big-O notation</strong>, I learned how to evaluate the performance of algorithms, especially for large input sizes. The ability to analyze an algorithm's <strong>best, worst, and average-case</strong> complexities helps select the optimal approach for solving problems.</p>
            <pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]</code></pre>

            <h3>2. Binary Search Tree (BST)</h3>
            <p>I gained a strong understanding of how <strong>BSTs</strong> allow efficient insertion, deletion, and search operations in logarithmic time. The main challenge was mastering tree traversal methods, both iterative and recursive, and understanding the importance of maintaining balance in the tree to ensure performance remains optimal.</p>
            <pre><code>class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.value = key

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.value:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root</code></pre>

            <h3>3. DFS and BFS</h3>
            <p><strong>DFS</strong> is useful for exploring paths deeply, while <strong>BFS</strong> is efficient for finding the shortest path in unweighted graphs. I implemented both in various graph scenarios, such as finding connected components or shortest paths.</p>
            <pre><code>def dfs(graph, node, visited):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)</code></pre>

            <h3>4. Heap Sorting</h3>
            <p><strong>Heap Sort</strong> introduced me to the importance of the heap data structure. I learned how the binary heap allows us to efficiently retrieve the smallest or largest element and perform sorting in <strong>O(n log n)</strong> time. The challenge was understanding how the heap property is maintained during insertions and deletions.</p>
            <pre><code>def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)</code></pre>

            <h3>5. Pattern Searching</h3>
            <p>I explored various algorithms for <strong>Pattern Searching</strong>, such as <strong>Knuth-Morris-Pratt (KMP)</strong>, which is highly efficient for finding substrings in a larger string. These algorithms optimize the brute-force approach by reducing unnecessary comparisons.</p>
            <pre><code>def KMP_search(text, pattern):
    lps = [0] * len(pattern)
    j = 0
    computeLPS(pattern, lps)
    i = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            print("Pattern found at index " + str(i - j))
            j = lps[j - 1]
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1</code></pre>

            <h3>6. Graph Algorithms</h3>
            <p>I learned the importance of <strong>graphs</strong> in representing real-world relationships, such as social networks and transportation systems. Key algorithms like <strong>Dijkstra’s Algorithm</strong> for shortest path finding and <strong>Prim’s Algorithm</strong> for minimum spanning trees helped me understand the complexities involved in graph-based problems.</p>
            <pre><code>def dijkstra(graph, start):
    shortest_paths = {start: (None, 0)}
    current_node = start
    while current_node is not None:
        weight = shortest_paths[current_node][1]
        for neighbor, w in graph[current_node].items():
            path_weight = weight + w
            if neighbor not in shortest_paths:
                shortest_paths[neighbor] = (current_node, path_weight)
            else:
                current_weight = shortest_paths[neighbor][1]
                if current_weight > path_weight:
                    shortest_paths[neighbor] = (current_node, path_weight)
        next_dest = None
        smallest_weight = float('inf')
        for node, paths in shortest_paths.items():
            if paths[1] < smallest_weight:
                smallest_weight = paths[1]
                next_dest = node
        current_node = next_dest
    return shortest_paths</code></pre>
        </section>

        <section class="challenges">
            <h2>Challenges in Learning and Understanding</h2>
            <p>Grasping the concepts of Time Complexity, DFS/BFS, and Pattern Searching required patience and practice, as well as understanding the underlying recursive nature of many algorithms. Heap Sort and Graph Algorithms were also difficult to implement initially due to their complexity and optimization techniques.</p>
        </section>

        <section class="real-world">
            <h2>Challenges in Relating to Real-World Applications</h2>
            <p>Time Complexity is theoretical, and applying it to real-world systems can sometimes be inaccurate due to factors like input size and hardware limitations. For algorithms like Graph Traversal and Heap Sorting, the scale of data in real-world applications requires additional optimizations to manage performance.</p>
        </section>

        <section class="approach">
            <h2>Approach to Solving Complex Problems</h2>
            <p>When solving complex problems, I analyze the problem, select the most appropriate algorithm based on time complexity, and continuously optimize the solution. Testing edge cases ensures robustness, and real-world benchmarking validates the performance of the solution.</p>
        </section>

        <footer>
            <p>Through this course, I gained a deeper understanding of data structures and algorithms, and I am now better equipped to solve real-world computational problems with efficiency and precision.</p>
        </footer>
    </div>
</body>
</html>
