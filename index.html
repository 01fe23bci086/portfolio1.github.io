<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
</head>
<body>
    <header>
        <h1>Hello, I'm Vaishnavi Tiwari üëã</h1>
        <p>I am passionate about technology and problem-solving. Here's a glimpse of my work:</p>
    </header>

    <section>
        <h2>üõ† Projects</h2>
        <ul>
            <li><strong>Project 1</strong>: Urea dispensing machine - It stores and dispenses urea fertilizer in liquid or granular form, ensuring precise application for improved crop yield and reduced waste.</li>
            <li><strong>Project 2</strong>: Smart gloves to overcome communication barriers - It translates sign language gestures into speech or text, enabling deaf and mute individuals to communicate easily with others.</li>
        </ul>

        <h2>üöÄ Skills</h2>
        <ul>
            <li>C, C++, Python</li>
            <li>Data structures</li>
            <li>Design analysis and algorithms</li>
        </ul>

        <h2>üåê Find Me Online</h2>
        <ul>
            <li><a href="https://github.com/01fe23bci086">GitHub</a></li>
            <li><a href="https://in.linkedin.com/in/vaishnavi-tiwari-541079296">LinkedIn</a></li>
        </ul>

        <h2>Portfolio Topic</h2>
        <dl>
            <dt>Course Name</dt>
            <dd>Design Analysis And Algorithm</dd>

            <dt>Course Code</dt>
            <dd>24ECAC203</dd>

            <dt>Name</dt>
            <dd>Vaishnavi Tiwari</dd>

            <dt>SRN</dt>
            <dd>01fe23bci086</dd>

            <dt>Course Instructor</dt>
            <dd>Mr. K M M Rajashekharaiah sir</dd>

            <dt>University</dt>
            <dd>KLE Technological University, Hubballi</dd>

            <dt>Portfolio Topic/Domain</dt>
            <dd>Google</dd>
        </dl>

        <blockquote>‚ÄúThe only way to do great work is to love what you do.‚Äù ‚Äì Steve Jobs</blockquote>
    </section>

    <section>
        <h2>üìö About this Course: Design Analysis and Algorithm</h2>
        <p>The <strong>Design Analysis and Algorithm</strong> course focuses on developing a solid foundation in designing, analyzing, and implementing algorithms to solve computational problems efficiently. It covers the essential techniques for optimizing algorithm performance with an emphasis on time and space complexity analysis.</p>
        
        <h3>Key Topics Covered:</h3>
        <ul>
            <li><strong>Time and Space Complexity:</strong> Learn to evaluate and compare algorithms using Big-O notation.</li>
            <li><strong>Sorting and Searching Algorithms:</strong> Study fundamental algorithms like QuickSort, MergeSort, and Binary Search.</li>
            <li><strong>Divide and Conquer:</strong> Solve problems by breaking them into smaller subproblems, such as matrix multiplication.</li>
            <li><strong>Dynamic Programming:</strong> Learn optimization techniques like the Knapsack problem and Fibonacci sequence.</li>
            <li><strong>Greedy Algorithms:</strong> Solve problems by making locally optimal choices, such as activity selection.</li>
            <li><strong>Graph Algorithms:</strong> Explore algorithms for graph-related problems, including DFS, BFS, Dijkstra‚Äôs, and Prim‚Äôs.</li>
            <li><strong>NP-Completeness:</strong> Understand computationally hard problems and their significance.</li>
        </ul>
        
        <h3>Course Outcome:</h3>
        <p>By the end of the course, students will be able to design efficient algorithms, analyze their performance, and apply them to solve real-world problems effectively.</p>
    </section>

    <!-- Buttons for Theory and Lab Reflections -->
    <section>
        <button id="toggleLabReflectionBtn" style="background-color: green; color: white; padding: 10px 20px; border: none; cursor: pointer;">click for Lab Reflections</button>
        <button id="toggleTheoryReflectionBtn" style="background-color: green; color: white; padding: 10px 20px; border: none; cursor: pointer;">click for Theory Reflections</button>
    </section>

    <!-- Lab Reflection Section -->
    <section id="labReflectionContent" style="display: none;">
        <h2>üìñ Reflection on Learning Data Structures and Algorithms</h2>
        <p>Throughout this course, I delved deep into fundamental data structures and algorithms, which are the backbone of efficient computing. Key topics I explored include <strong>Time Complexity Analysis</strong>, <strong>Binary Search Trees (BST)</strong>, <strong>DFS and BFS</strong>, <strong>Heap Sorting</strong>, <strong>Pattern Searching</strong>, and <strong>Graph Algorithms</strong>. Here's a reflection on what I learned, the challenges I faced, and how I approached solving complex problems.</p>

        <h3>Key Concepts Learned</h3>
        <h4>1. Time Complexity Analysis</h4>
        <p>Time complexity analysis is essential for determining the efficiency of algorithms. By mastering <strong>Big-O notation</strong>, I learned how to evaluate the performance of algorithms, especially for large input sizes. The ability to analyze an algorithm's <strong>best, worst, and average-case</strong> complexities helps select the optimal approach for solving problems.</p>

        <pre><code>def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]</code></pre>

        <h4>2. Binary Search Tree (BST)</h4>
        <p>I gained a strong understanding of how <strong>BSTs</strong> allow efficient insertion, deletion, and search operations in logarithmic time. The main challenge was mastering tree traversal methods, both iterative and recursive, and understanding the importance of maintaining balance in the tree to ensure performance remains optimal.</p>

        <pre><code>class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.value = key

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.value:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root</code></pre>

        <h4>3. DFS and BFS</h4>
        <p><strong>DFS</strong> is useful for exploring paths deeply, while <strong>BFS</strong> is efficient for finding the shortest path in unweighted graphs. I implemented both in various graph scenarios, such as finding connected components or shortest paths.</p>

        <pre><code>def dfs(graph, node, visited):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbor in graph[node]:
            dfs(graph, neighbor, visited)</code></pre>

        <h4>4. Heap Sorting</h4>
        <p><strong>Heap Sort</strong> introduced me to the importance of the heap data structure. I learned how the binary heap allows us to efficiently retrieve the smallest or largest element and perform sorting in <strong>O(n log n)</strong> time. The challenge was understanding how the heap property is maintained during insertions and deletions.</p>

        <pre><code>def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)</code></pre>

        <h4>5. Pattern Searching</h4>
        <p>I explored various algorithms for <strong>Pattern Searching</strong>, such as <strong>Knuth-Morris-Pratt (KMP)</strong>, which is highly efficient for finding substrings in a larger string. These algorithms optimize the brute-force approach by reducing unnecessary comparisons.</p>

        <pre><code>def KMP_search(text, pattern):
    lps = [0] * len(pattern)
    j = 0
    computeLPS(pattern, lps)
    i = 0
    while i < len(text):
        if pattern[j] == text[i]:
            i += 1
            j += 1
        if j == len(pattern):
            print("Pattern found at index " + str(i - j))
            j = lps[j - 1]
        elif i < len(text) and pattern[j] != text[i]:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1</code></pre>

        <h4>6. Graph Algorithms</h4>
        <p>I learned the importance of <strong>graphs</strong> in representing real-world relationships, such as in social networks or transport systems. Implementing algorithms like <strong>Dijkstra's</strong> and <strong>Prim's</strong> for shortest paths and minimum spanning trees, respectively, was a rewarding challenge.</p>

        <pre><code>import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    priority_queue = [(0, start)]

    while priority_queue:
        current_distance, current_vertex = heapq.heappop(priority_queue)

        for neighbor, weight in graph[current_vertex].items():
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))

    return distances</code></pre>

        <h3>Challenges Faced</h3>
        <p>One of the biggest challenges was understanding the time and space complexities associated with each algorithm. For example, sorting algorithms like MergeSort require careful handling of memory allocation, and understanding recursive calls in depth-first search was tricky but rewarding once I understood the underlying mechanism.</p>

        <h3>Challenges in Relating to Real-World Applications</h3>
        <p>Time Complexity is theoretical, and applying it to real-world systems can sometimes be inaccurate due to factors like input size and hardware limitations. For algorithms like Graph Traversal and Heap Sorting, the scale of data in real-world applications requires additional optimizations to manage performance.</p>

        <h3>Approach and Strategy</h3>
        <p>My approach involved a balance of theory and practical implementation. After understanding the theoretical foundations, I would try to implement each algorithm from scratch, and debug my code thoroughly. Working on different problems helped me consolidate my understanding and improve my problem-solving skills.</p>
    </section>

    <!-- Theory Reflection Section -->
    <section id="theoryReflectionContent" style="display: none;">
        <h2>üìñ Reflection on Learning Theory in Design Analysis and Algorithm</h2>
        <p>This course has provided me with a comprehensive understanding of the theoretical aspects of algorithm design. I have learned essential techniques such as divide and conquer, dynamic programming, greedy algorithms, and graph algorithms. I now understand the theoretical foundations behind optimizing algorithm efficiency using time and space complexity analysis.</p>

        <h3>Key Concepts</h3>
        <ul>
            <li>Time Complexity: Understanding <strong>Big-O Notation</strong> to analyze the efficiency of algorithms.</li>
            <li>Divide and Conquer: Breaking down problems into subproblems and solving them recursively.</li>
            <li>Greedy Algorithms: Making optimal choices at each step.</li>
            <li>Graph Algorithms: Understanding how to represent and manipulate graphs to solve real-world problems.</li>
        </ul>

        <h3>Theory Learning Outcomes</h3>
        <p>By the end of this course, I am able to:</p>
        <ul>
            <li>Understand and apply the principles of algorithm design.</li>
            <li>Evaluate the efficiency of algorithms using time and space complexity.</li>
            <li>Implement various algorithms such as sorting, searching, and graph traversal.</li>
            <li>Identify appropriate problem-solving strategies, such as divide and conquer or dynamic programming, for different scenarios.</li>
            <li>Understand the importance of selecting the right algorithm for different data structures and problem contexts.</li>
        </ul>

        <h3>Challenges Faced</h3>
        <p>One of the biggest challenges was understanding the complexity analysis in real-world applications. Time complexity in theoretical scenarios doesn‚Äôt always map perfectly to real-world performance due to factors like system architecture, input size, and optimization strategies.</p>

        <h3>Challenges in Relating to Real-World Applications</h3>
        <p>Time Complexity is theoretical, and applying it to real-world systems can sometimes be inaccurate due to factors like input size and hardware limitations. For algorithms like Graph Traversal and Heap Sorting, the scale of data in real-world applications requires additional optimizations to manage performance.</p>

        <h3>Approach and Strategy</h3>
        <p>My approach involved a balance of theory and practical implementation. After understanding the theoretical foundations, I would try to implement each algorithm from scratch, and debug my code thoroughly. Working on different problems helped me consolidate my understanding and improve my problem-solving skills.</p>
    </section>

    <script>
        const toggleLabReflectionBtn = document.getElementById('toggleLabReflectionBtn');
        const toggleTheoryReflectionBtn = document.getElementById('toggleTheoryReflectionBtn');
        const labReflectionContent = document.getElementById('labReflectionContent');
        const theoryReflectionContent = document.getElementById('theoryReflectionContent');

        toggleLabReflectionBtn.addEventListener('click', () => {
            theoryReflectionContent.style.display = 'none';
            labReflectionContent.style.display = labReflectionContent.style.display === 'none' ? 'block' : 'none';
        });

        toggleTheoryReflectionBtn.addEventListener('click', () => {
            labReflectionContent.style.display = 'none';
            theoryReflectionContent.style.display = theoryReflectionContent.style.display === 'none' ? 'block' : 'none';
        });
    </script>
</body>
</html>
